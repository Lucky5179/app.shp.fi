var dt=Object.defineProperty;var pt=(k,t,e)=>t in k?dt(k,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):k[t]=e;var x=(k,t,e)=>(pt(k,typeof t!="symbol"?t+"":t,e),e);import{gE as H,c6 as Y,en as Q,el as G,bO as rt,hc as ct,bL as lt,ep as ht,gx as mt,Y as F,hl as M,bP as wt,aQ as yt,bD as S,he as Z,hf as C,cC as z,gu as L,hh as J,gt as kt,hA as gt,hg as K,bN as ft,hi as X,h9 as Tt,ha as W,ck as j,a_ as _t,hj as vt,es as V,hk as At,hq as tt,h8 as et,hx as xt,hv as qt,hn as ot,cT as it,hm as It,hz as bt,hy as Lt}from"./index-e33bfe5b.js";import{c as nt,h as st,a as D}from"./amounts-328c917b.js";import{f as Ot}from"./swap-53be301f.js";import{B as Qt}from"./Balances-1942d032.js";import{g as q,a as f,N as at}from"./zap-1e909aff.js";function Et(k,t,e,o=!1){return{target:k,value:"0",data:H.encodeFunctionCall({type:"function",name:"approve",constant:!1,payable:!1,inputs:[{type:"address",name:"spender"},{type:"uint256",name:"amount"}],outputs:[{type:"bool",name:"success"}]},[t,e.toString(10)]),tokens:o?[{token:k,index:q(1)}]:[]}}const St={fixed:{depositQuote:"calc_token_amount:fixed_amounts",deposit:"add_liquidity:fixed_amounts/min_amount",withdrawQuote:"calc_withdraw_one_coin:amount/uint256_index",withdraw:"remove_liquidity_one_coin:amount/uint256_index/min_amount"},"fixed-deposit-int128":{depositQuote:"calc_token_amount:fixed_amounts/is_deposit",deposit:"add_liquidity:fixed_amounts/min_amount",withdrawQuote:"calc_withdraw_one_coin:amount/int128_index",withdraw:"remove_liquidity_one_coin:amount/int128_index/min_amount"},"fixed-deposit-uint256":{depositQuote:"calc_token_amount:fixed_amounts/is_deposit",deposit:"add_liquidity:fixed_amounts/min_amount",withdrawQuote:"calc_withdraw_one_coin:amount/uint256_index",withdraw:"remove_liquidity_one_coin:amount/uint256_index/min_amount"},"fixed-deposit-underlying":{depositQuote:"calc_token_amount:fixed_amounts/is_deposit",deposit:"add_liquidity:fixed_amounts/min_amount/use_underlying",withdrawQuote:"calc_withdraw_one_coin:amount/int128_index",withdraw:"remove_liquidity_one_coin:amount/int128_index/min_amount/use_underlying"},"dynamic-deposit":{depositQuote:"calc_token_amount:dynamic_amounts/is_deposit",deposit:"add_liquidity:dynamic_amounts/min_amount",withdrawQuote:"calc_withdraw_one_coin:amount/int128_index",withdraw:"remove_liquidity_one_coin:amount/int128_index/min_amount"},"pool-fixed":{depositQuote:"calc_token_amount:pool/fixed_amounts",deposit:"add_liquidity:pool/fixed_amounts/min_amount",withdrawQuote:"calc_withdraw_one_coin:pool/amount/uint256_index",withdraw:"remove_liquidity_one_coin:pool/amount/uint256_index/min_amount"},"pool-fixed-deposit":{depositQuote:"calc_token_amount:pool/fixed_amounts/is_deposit",deposit:"add_liquidity:pool/fixed_amounts/min_amount",withdrawQuote:"calc_withdraw_one_coin:pool/amount/int128_index",withdraw:"remove_liquidity_one_coin:pool/amount/int128_index/min_amount"},"pool-dynamic-deposit":{depositQuote:"calc_token_amount:pool/dynamic_amounts/is_deposit",deposit:"add_liquidity:pool/dynamic_amounts/min_amount",withdrawQuote:"calc_withdraw_one_coin:pool/amount/int128_index",withdraw:"remove_liquidity_one_coin:pool/amount/int128_index/min_amount"}};function $(k){return St[k]}class O{constructor(t,e,o,i){this.option=t,this.poolAddress=e,this.chain=o,this.depositToken=i}async quoteAddLiquidity(t){const e=await Y(this.chain),o=new e.eth.Contract([this.typeToAddLiquidityQuoteAbi(this.option.type,this.option.numCoins)],this.option.target),i=this.makeAmounts(Q(t,this.option.token.decimals),this.option.index,this.option.numCoins),r=this.typeToAddLiquidityQuoteParams(this.option.type,this.poolAddress,i);console.log(this.option.type,this.option.target,"calc_token_amount",r);const u=await o.methods.calc_token_amount(...r).call();return console.log("->",u),{token:this.depositToken,amount:G(u,this.depositToken.decimals)}}typeToAddLiquidityQuoteAbi(t,e){const o=$(t);return this.signatureToAbiItem(o.depositQuote,e)}typeToAddLiquidityQuoteParams(t,e,o){switch(t){case"fixed":return[o];case"fixed-deposit-int128":case"fixed-deposit-uint256":case"dynamic-deposit":case"fixed-deposit-underlying":return[o,!0];case"pool-fixed":return[e,o];case"pool-fixed-deposit":case"pool-dynamic-deposit":return[e,o,!0];default:throw new Error(`Invalid deposit type ${t}`)}}buildZapAddLiquidityTx(t,e,o){const i=this.makeAmounts(t.toString(10),this.option.index,this.option.numCoins),r=this.typeToAddLiquidityTokenIndexes(this.option.type,i),u=rt(this.option.token),s=this.typeToAddLiquidityAbi(this.option.type,this.option.numCoins),n=this.typeToAddLiquidityParams(this.option.type,this.poolAddress,i,e.toString(10));return{target:this.option.target,value:u?t.toString(10):"0",data:H.encodeFunctionCall(s,n),tokens:o?[{token:f(this.option.token),index:r[this.option.index]}]:[]}}typeToAddLiquidityTokenIndexes(t,e){switch(t){case"fixed":case"fixed-deposit-int128":case"fixed-deposit-uint256":case"fixed-deposit-underlying":return e.map((o,i)=>q(i));case"dynamic-deposit":return e.map((o,i)=>q(3+i));case"pool-fixed":case"pool-fixed-deposit":return e.map((o,i)=>q(1+i));case"pool-dynamic-deposit":return e.map((o,i)=>q(4+i));default:throw new Error(`Invalid deposit type ${t}`)}}typeToAddLiquidityAbi(t,e){const o=$(t);return this.signatureToAbiItem(o.deposit,e,"payable")}typeToAddLiquidityParams(t,e,o,i){switch(t){case"fixed":case"fixed-deposit-int128":case"fixed-deposit-uint256":case"dynamic-deposit":return[o,i];case"fixed-deposit-underlying":return[o,i,!0];case"pool-fixed":case"pool-fixed-deposit":case"pool-dynamic-deposit":return[e,o,i];default:throw new Error(`Invalid deposit type ${t}`)}}async quoteRemoveLiquidity(t){const e=await Y(this.chain),o=new e.eth.Contract([this.typeToRemoveLiquidityQuoteAbi(this.option.type,this.option.numCoins)],this.option.target),i=Q(t,this.depositToken.decimals),r=this.typeToRemoveLiquidityQuoteParams(this.option.type,this.poolAddress,i,this.option.index);console.log(this.option.type,this.option.target,"calc_withdraw_one_coin",r);const u=await o.methods.calc_withdraw_one_coin(...r).call();return console.log("->",u),{token:this.option.token,amount:G(u,this.option.token.decimals)}}typeToRemoveLiquidityQuoteAbi(t,e){const o=$(t);return this.signatureToAbiItem(o.withdrawQuote,e)}typeToRemoveLiquidityQuoteParams(t,e,o,i){switch(t){case"fixed":case"fixed-deposit-int128":case"fixed-deposit-uint256":case"dynamic-deposit":case"fixed-deposit-underlying":return[o,i];case"pool-fixed":case"pool-fixed-deposit":case"pool-dynamic-deposit":return[e,o,i];default:throw new Error(`Invalid withdraw type ${t}`)}}buildZapRemoveLiquidityTx(t,e,o){const i=this.typeToRemoveLiquidityAbi(this.option.type,this.option.numCoins),r=this.typeToRemoveLiquidityParams(this.option.type,this.poolAddress,t.toString(10),this.option.index,e.toString(10));return{target:this.option.target,value:"0",data:H.encodeFunctionCall(i,r),tokens:o?[{token:this.depositToken.address,index:this.typeToRemoveLiquidityTokenIndex(this.option.type)}]:[]}}typeToRemoveLiquidityTokenIndex(t){switch(t){case"fixed":case"fixed-deposit-int128":case"fixed-deposit-uint256":case"dynamic-deposit":case"fixed-deposit-underlying":return q(0);case"pool-fixed":case"pool-fixed-deposit":case"pool-dynamic-deposit":return q(1);default:throw new Error(`Invalid withdraw type ${t}`)}}typeToRemoveLiquidityAbi(t,e){const o=$(t);return this.signatureToAbiItem(o.withdraw,e,"payable")}typeToRemoveLiquidityParams(t,e,o,i,r){switch(t){case"fixed":case"fixed-deposit-int128":case"fixed-deposit-uint256":case"dynamic-deposit":return[o,i,r];case"fixed-deposit-underlying":return[o,i,r,!0];case"pool-fixed":case"pool-fixed-deposit":case"pool-dynamic-deposit":return[e,o,i,r];default:throw new Error(`Invalid withdraw type ${t}`)}}makeAmounts(t,e,o){const i=Array(o).fill("0");return i[e]=t,i}signatureToAbiItem(t,e,o="view"){const[i,r]=t.split(":"),u=r.split("/");return{type:"function",name:i,stateMutability:o,inputs:u.map(s=>{switch(s){case"fixed_amounts":return{name:"amounts",type:`uint256[${e}]`};case"dynamic_amounts":return{name:"amounts",type:"uint256[]"};case"amount":case"min_amount":return{name:s,type:"uint256"};case"uint256_index":return{name:"index",type:"uint256"};case"int128_index":return{name:"index",type:"int128"};case"is_deposit":case"use_underlying":return{name:s,type:"bool"};case"pool":return{name:s,type:"address"};default:throw new Error(`Invalid input type ${s}`)}}),outputs:[{name:"amount",type:"uint256"}]}}}class Nt{constructor(t,e){x(this,"id","curve");x(this,"native");x(this,"wnative");x(this,"possibleTokens");x(this,"chain");x(this,"depositToken");x(this,"poolAddress");this.options=t,this.helpers=e;const{vault:o,vaultType:i,getState:r}=this.helpers;ct(o);const u=r();for(let s=0;s<o.assetIds.length;++s)if(!lt(u,o.chainId,o.assetIds[s]))throw new Error(`Vault ${o.id}: Asset ${o.assetIds[s]} not loaded`);if(this.native=ht(u,o.chainId),this.wnative=mt(u,o.chainId),this.depositToken=i.depositToken,this.chain=F(u,o.chainId),this.possibleTokens=this.selectAvailableTokens(u,this.chain.id,this.options.methods),this.poolAddress=this.options.poolAddress||this.depositToken.address,!this.possibleTokens.length)throw new Error(`Vault ${o.id}: No tokens configured are available in addressbook, wanted one of ${this.options.methods.flatMap(s=>s.coins).join(", ")}`)}selectAvailableTokens(t,e,o){return M(o.flatMap(i=>i.coins.map((r,u)=>{const s=wt(t,e,r);return{type:i.type,target:i.target,index:u,numCoins:i.coins.length,token:s,price:s&&yt(t,s.oracleId)}})).filter(i=>!!i.token&&!!i.price&&i.price.gt(S)),i=>`${i.token.chainId}-${i.token.address}`)}async fetchDepositOptions(){const{vault:t,vaultType:e}=this.helpers,o=[e.depositToken],i=this.possibleTokens.map(n=>{const a=[n.token],d=Z(t.chainId,a);return{id:C(this.id,t.id,d,"direct"),vaultId:t.id,chainId:t.chainId,selectionId:d,selectionOrder:2,inputs:a,wantedOutputs:o,mode:z.Deposit,strategyId:"curve",via:"direct",viaToken:n}}),{any:r,map:u}=await this.aggregatorTokenSupport(),s=r.filter(n=>u[n.address].length>0).map(n=>{const a=[n],d=Z(t.chainId,a),p=u[n.address];if(p.length===0)throw console.error({vault:t.id,token:n,possible:p}),new Error(`No other tokens supported for ${n.symbol}`);return{id:C(this.id,t.id,d,"aggregator"),vaultId:t.id,chainId:t.chainId,selectionId:d,selectionOrder:3,inputs:a,wantedOutputs:o,mode:z.Deposit,strategyId:"curve",via:"aggregator",viaTokens:p}});return i.concat(s)}async getDepositLiquidityDirect(t,e){if(!L(t.token,e.token))throw new Error(`Curve strategy: Direct deposit called with input token ${t.token.symbol} but expected ${e.token.symbol}`);const i=await new O(e,this.poolAddress,this.chain,this.depositToken).quoteAddLiquidity(t.amount);return{input:t,output:i,via:e}}async getDepositLiquidityAggregator(t,e,o){const{vault:i,swapAggregator:r}=this.helpers,s=(await Promise.allSettled(o.map(async a=>{const d=await r.fetchQuotes({vaultId:i.id,fromToken:e.token,fromAmount:e.amount,toToken:a.token},t),p=J(d);if(!p)throw new Error(`No quote for ${e.token.symbol} to ${a.token.symbol}`);return{via:a,quote:p}}))).filter(kt).map(a=>a.value).filter(gt);if(!s.length)throw new Error(`No quotes for ${e.token.symbol} to any deposit via token`);const n=await Promise.all(s.map(async({via:a,quote:d})=>{const p=new O(a,this.poolAddress,this.chain,this.depositToken);return{via:a,quote:d,input:{token:d.toToken,amount:d.toAmount},output:await p.quoteAddLiquidity(d.toAmount)}}));return n.sort((a,d)=>d.output.amount.comparedTo(a.output.amount)),n[0]}async getDepositLiquidity(t,e,o){return o.via==="direct"?this.getDepositLiquidityDirect(e,o.viaToken):this.getDepositLiquidityAggregator(t,e,o.viaTokens)}async fetchDepositQuote(t,e){const{zap:o,getState:i}=this.helpers,r=i(),u=K(t);if(u.amount.lte(S))throw new Error("Curve strategy: Quote called with 0 input amount");const s=ft(u.token)?[{token:u.token,amount:u.amount,spenderAddress:o.manager}]:[],n=await this.getDepositLiquidity(r,u,e),a=[];n.quote&&a.push({type:"swap",fromToken:n.quote.fromToken,fromAmount:n.quote.fromAmount,toToken:n.quote.toToken,toAmount:n.quote.toAmount,via:"aggregator",providerId:n.quote.providerId,fee:n.quote.fee,quote:n.quote}),a.push({type:"build",inputs:[n.input],outputToken:n.output.token,outputAmount:n.output.amount}),a.push({type:"deposit",token:n.output.token,amount:n.output.amount});const d=[n.output],p=[];return{id:X(e.id),strategyId:"curve",priceImpact:nt(t,d,p,r),option:e,inputs:t,outputs:d,returned:p,allowances:s,steps:a,fee:st(a),via:e.via,viaToken:n.via}}async fetchZapSwap(t,e,o){if(Tt(t))return this.fetchZapSwapAggregator(t,e,o);throw new Error("Unknown zap quote swap step type")}async fetchZapSwapAggregator(t,e,o){const{swapAggregator:i,zap:r}=this.helpers,{slippage:u,state:s}=e;return await Ot({quote:t.quote,inputs:[{token:t.fromToken,amount:t.fromAmount}],outputs:[{token:t.toToken,amount:t.toAmount}],maxSlippage:u,zapRouter:r.router,providerId:t.providerId,insertBalance:o},i,s)}async fetchZapBuild(t,e,o,i,r=!1){const{slippage:u}=i,s=new O(e,this.poolAddress,this.chain,this.depositToken),n=await s.quoteAddLiquidity(o),a=D(n.amount,u,n.token.decimals);return{inputs:[{token:e.token,amount:o}],outputs:[n],minOutputs:[{token:n.token,amount:a}],returned:[],zaps:[s.buildZapAddLiquidityTx(W(o,e.token.decimals),W(a,n.token.decimals),r)]}}async fetchDepositStep(t,e){const{vault:o,vaultType:i}=this.helpers,r=async(u,s,n)=>{const a=s(),d=F(a,o.chainId),p=j(a),T={chain:d,slippage:p,state:a,poolAddress:this.options.poolAddress||this.depositToken.address},y=[],w=new Qt(t.inputs),g=t.steps.filter(et),m=t.steps.find(xt);if(!m)throw new Error("CurveStrategy: No build step in quote");if(g.length>2)throw new Error("CurveStrategy: Too many swaps");if(g.length){if(g.length>1)throw new Error("CurveStrategy: Too many swaps in quote");const h=g[0],l=await this.fetchZapSwap(h,T,!0);l.zaps.forEach(N=>y.push(N)),w.subtractMany(l.inputs),w.addMany(l.minOutputs)}const v=await this.fetchZapBuild(m,t.viaToken,w.get(t.viaToken.token),T,!0);console.debug("fetchDepositStep::buildZap",qt(v)),v.zaps.forEach(h=>y.push(h)),w.subtractMany(v.inputs),w.addMany(v.minOutputs);const c=await i.fetchZapDeposit({inputs:[{token:m.outputToken,amount:w.get(m.outputToken),max:!0}]});console.log("fetchDepositStep::vaultDeposit",c),y.push(c.zap);const _=t.inputs.map(h=>({token:f(h.token),amount:Q(h.amount,h.token.decimals)})),I=c.outputs.map(h=>({token:f(h.token),minOutputAmount:Q(D(h.amount,p,h.token.decimals),h.token.decimals)})),A=ot(t.outputs,t.inputs,t.returned).map(h=>({token:f(h),minOutputAmount:"0"}));g.forEach(h=>{A.push({token:f(h.fromToken),minOutputAmount:"0"}),A.push({token:f(h.toToken),minOutputAmount:"0"})}),A.push({token:f(m.outputToken),minOutputAmount:"0"});const E=M(I.concat(A),h=>h.token),R={order:{inputs:_,outputs:E,relay:at},steps:y},P=c.outputs.map(h=>h.token);return it.zapExecuteOrder(t.option.vaultId,R,P)(u,s,n)};return{step:"zap-in",message:e("Vault-TxnConfirm",{type:e("Deposit-noun")}),action:r,pending:!1,extraInfo:{zap:!0,vaultId:t.option.vaultId}}}async fetchWithdrawOptions(){const{vault:t,vaultType:e}=this.helpers,o=[e.depositToken],i=this.possibleTokens.map(n=>{const a=[n.token],d=Z(t.chainId,a);return{id:C(this.id,t.id,d,"direct"),vaultId:t.id,chainId:t.chainId,selectionId:d,selectionOrder:2,inputs:o,wantedOutputs:a,mode:z.Withdraw,strategyId:"curve",via:"direct",viaToken:n}}),{any:r,map:u}=await this.aggregatorTokenSupport(),s=r.filter(n=>u[n.address].length>0).map(n=>{const a=[n],d=Z(t.chainId,a),p=u[n.address];if(p.length===0)throw console.error({vault:t.id,token:n,possible:p}),new Error(`No other tokens supported for ${n.symbol}`);return{id:C(this.id,t.id,d,"aggregator"),vaultId:t.id,chainId:t.chainId,selectionId:d,selectionOrder:3,inputs:o,wantedOutputs:a,mode:z.Withdraw,strategyId:"curve",via:"aggregator",viaTokens:p}});return i.concat(s)}async getWithdrawLiquidityDirect(t,e,o){if(!L(e,o.token))throw new Error(`Curve strategy: Direct withdraw called with wanted token ${t.token.symbol} but expected ${o.token.symbol}`);const r=await new O(o,this.poolAddress,this.chain,this.depositToken).quoteRemoveLiquidity(t.amount);return{input:t,split:r,output:r,via:o}}async getWithdrawLiquidityAggregator(t,e,o,i){const{vault:r,swapAggregator:u}=this.helpers,s=j(t),n=await Promise.all(i.map(async d=>{const T=await new O(d,this.poolAddress,this.chain,this.depositToken).quoteRemoveLiquidity(e.amount);return{via:d,split:T}})),a=await Promise.all(n.map(async({via:d,split:p})=>{const T=await u.fetchQuotes({vaultId:r.id,fromToken:p.token,fromAmount:D(p.amount,s,p.token.decimals),toToken:o},t),y=J(T);return{via:d,quote:y,input:e,split:p,output:{token:o,amount:y?y.toAmount:S}}}));return a.sort((d,p)=>p.output.amount.comparedTo(d.output.amount)),a[0]}async getWithdrawLiquidity(t,e,o,i){return i.via==="direct"?this.getWithdrawLiquidityDirect(e,o,i.viaToken):this.getWithdrawLiquidityAggregator(t,e,o,i.viaTokens)}async fetchWithdrawQuote(t,e){const o=K(t);if(o.amount.lte(S))throw new Error("Quote called with 0 input amount");if(e.wantedOutputs.length!==1)throw new Error("Can only swap to 1 output token");const{vault:i,vaultType:r,zap:u,getState:s}=this.helpers;if(!_t(i))throw new Error("Vault is not standard");const n=s(),{withdrawnAmountAfterFeeWei:a,withdrawnToken:d,shareToken:p,sharesToWithdrawWei:T}=vt(o,i,n),y=V(a,d.decimals),w={amount:y,token:d},g=At(e.wantedOutputs),m=[],v=[{token:p,amount:V(T,p.decimals),spenderAddress:u.manager}],c=await this.getWithdrawLiquidity(n,w,g,e),_=[{type:"withdraw",token:r.depositToken,amount:y}];if(_.push({type:"split",inputToken:c.input.token,inputAmount:c.input.amount,outputs:[c.split]}),c.quote){_.push({type:"swap",fromToken:c.quote.fromToken,fromAmount:c.quote.fromAmount,toToken:c.quote.toToken,toAmount:c.quote.toAmount,via:"aggregator",providerId:c.quote.providerId,fee:c.quote.fee,quote:c.quote});const A=c.split.amount.minus(c.quote.fromAmount);A.gt(S)&&m.push({token:c.split.token,amount:A})}m.length>0&&_.push({type:"unused",outputs:m});const I=[c.output];return{id:X(e.id),strategyId:"curve",priceImpact:nt(t,I,m,n),option:e,inputs:t,outputs:I,returned:m,allowances:v,steps:_,via:e.via,viaToken:c.via,fee:st(_)}}async fetchZapSplit(t,e,o,i,r=!1){const{slippage:u}=i,s=tt(e),n=new O(o,this.poolAddress,this.chain,this.depositToken),a=await n.quoteRemoveLiquidity(s.amount),d=D(a.amount,u,a.token.decimals),p=[n.buildZapRemoveLiquidityTx(W(s.amount,s.token.decimals),W(d,a.token.decimals),r)];return o.target!==this.poolAddress&&p.unshift(Et(s.token.address,o.target,W(s.amount,s.token.decimals),r)),{inputs:e,outputs:[a],minOutputs:[{token:a.token,amount:d}],returned:[],zaps:p}}async fetchWithdrawStep(t,e){const{vault:o,vaultType:i}=this.helpers,r=async(u,s,n)=>{const a=s(),d=F(a,o.chainId),p=j(a),T={chain:d,slippage:p,state:a,poolAddress:this.options.poolAddress||this.depositToken.address},y=t.steps.find(It),w=t.steps.filter(et),g=t.steps.find(bt);if(!y||!g)throw new Error("Withdraw quote missing withdraw or split step");const m=await i.fetchZapWithdraw({inputs:t.inputs});if(m.outputs.length!==1)throw new Error("Withdraw output count mismatch");const v=tt(m.outputs);if(!L(v.token,g.inputToken))throw new Error("Withdraw output token mismatch");if(v.amount.lt(y.toAmount))throw new Error("Withdraw output amount mismatch");const c=[m.zap],_=await this.fetchZapSplit(g,[v],t.viaToken,T,!0);if(_.zaps.forEach(l=>c.push(l)),w.length>0){if(w.length>_.minOutputs.length)throw new Error("More swap quotes than expected outputs");const l=Lt(w.map(b=>b.fromToken)),N=w.length-1;(await Promise.all(w.map((b,B)=>{if(!_.minOutputs.find(ut=>L(ut.token,b.fromToken)))throw new Error("Swap input not found in split outputs");return this.fetchZapSwap(b,T,l||N===B)}))).forEach(b=>b.zaps.forEach(B=>c.push(B)))}const I=m.inputs.map(l=>({token:f(l.token),amount:Q(l.amount,l.token.decimals)})),A=t.outputs.map(l=>({token:f(l.token),minOutputAmount:Q(D(l.amount,p,l.token.decimals),l.token.decimals)})),E=ot(m.inputs,t.outputs,t.inputs,t.returned,g.outputs).map(l=>({token:f(l),minOutputAmount:"0"}));w.forEach(l=>{E.push({token:f(l.fromToken),minOutputAmount:"0"}),E.push({token:f(l.toToken),minOutputAmount:"0"})});const R=M(A.concat(E),l=>l.token),P={order:{inputs:I,outputs:R,relay:at},steps:c},U=t.outputs.map(l=>l.token);return it.zapExecuteOrder(t.option.vaultId,P,U)(u,s,n)};return{step:"zap-out",message:e("Vault-TxnConfirm",{type:e("Withdraw-noun")}),action:r,pending:!1,extraInfo:{zap:!0,vaultId:t.option.vaultId}}}async aggregatorTokenSupport(){const{vault:t,swapAggregator:e,getState:o}=this.helpers,i=o(),r=await e.fetchTokenSupport(this.possibleTokens.map(u=>u.token),t.id,t.chainId,i,this.options.swap);return{...r,map:Object.fromEntries(r.any.map(u=>[u.address,this.possibleTokens.filter((s,n)=>!rt(s.token)&&!L(s.token,u)&&r.tokens[n].length>1&&r.tokens[n].some(a=>L(a,s.token)))]))}}}export{Nt as CurveStrategy};
