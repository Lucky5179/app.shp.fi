var N=Object.defineProperty;var V=(o,e,t)=>e in o?N(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t;var c=(o,e,t)=>(V(o,typeof e!="symbol"?e+"":e,t),t);import{aW as Q,P as I,bN as W,cs as z,bX as b,bD as y,hB as d,hh as l,gu as p,Y as C,c6 as A,hC as P,ha as f,hv as D,es as m,bO as E,gE as k,en as F,he as S,hf as x,cC as Z,hi as O,cT as B,hj as R,c7 as _,aT as j,hD as G}from"./index-e33bfe5b.js";import{a as w,g as v}from"./zap-1e909aff.js";class Y{constructor(e,t){c(this,"id","multistrategy");c(this,"vault");c(this,"depositToken");c(this,"shareToken");c(this,"getState");if(!Q(e))throw new Error("Vault is not a standard vault");const a=t();this.getState=t,this.vault=e,this.depositToken=I(a,e.chainId,e.depositTokenAddress);const n=I(a,e.chainId,e.earnContractAddress);if(!W(n))throw new Error("Share token is not an ERC20 token");this.shareToken=n}async initialize(){}calculateDepositFee(e,t){const{deposit:a}=z(t,this.vault.id);return a>0?e.amount.multipliedBy(a).decimalPlaces(e.token.decimals,b.ROUND_FLOOR):y}async fetchZapDeposit(e){d(e.inputs,1);const t=l(e.inputs);if(!p(t.token,this.depositToken))throw new Error("Input token is not the deposit token");const a=this.getState(),n=C(a,this.vault.chainId),s=await A(n),i=await new s.eth.Contract(P,this.vault.earnContractAddress).methods.getPricePerFullShare().call(),u=new b(i),h=f(t.amount,t.token.decimals),M=this.calculateDepositFee(t,a),T=f(t.amount.minus(M),t.token.decimals),g=T.shiftedBy(this.shareToken.decimals).dividedToIntegerBy(u);return console.log("fetchZapDeposit",D({ppfsRaw:i,inputWei:h,inputWeiAfterFee:T,expectedShares:g})),{inputs:e.inputs,outputs:[{token:this.shareToken,amount:m(g,this.shareToken.decimals)}],zap:E(t.token)?this.fetchNativeZapDeposit(this.vault.earnContractAddress,t.token,t.amount):this.fetchErc20ZapDeposit(this.vault.earnContractAddress,t.token,t.amount)}}fetchErc20ZapDeposit(e,t,a){return{target:e,value:"0",data:k.encodeFunctionCall({constant:!1,inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"deposit",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function"},[F(a,t.decimals)]),tokens:[{token:w(t),index:v(0)}]}}fetchNativeZapDeposit(e,t,a){return{target:e,value:F(a,t.decimals),data:k.encodeFunctionCall({constant:!1,inputs:[],name:"depositBNB",outputs:[],payable:!0,stateMutability:"payable",type:"function"},[]),tokens:[{token:w(t),index:-1}]}}async fetchDepositOption(){const e=[this.depositToken],t=S(this.vault.chainId,e);return{id:x("vault-standard",this.vault.id,t),vaultId:this.vault.id,chainId:this.vault.chainId,selectionId:t,selectionOrder:1,inputs:e,wantedOutputs:e,strategyId:"vault",vaultType:"standard",mode:Z.Deposit}}async fetchDepositQuote(e,t){d(e,1);const a=l(e);if(a.amount.lte(y))throw new Error("Quote called with 0 input amount");if(!p(a.token,this.depositToken))throw new Error("Quote called with invalid input token");const n=this.getState(),s=this.calculateDepositFee(a,n),r={token:a.token,amount:a.amount.minus(s)},i=W(a.token)?[{token:a.token,amount:a.amount,spenderAddress:this.vault.earnContractAddress}]:[];return{id:O(t.id),strategyId:t.strategyId,vaultType:t.vaultType,option:t,inputs:e,outputs:[r],returned:[],allowances:i,priceImpact:0}}async fetchDepositStep(e,t){d(e.inputs,1);const a=l(e.inputs);return{step:"deposit",message:t("Vault-TxnConfirm",{type:t("Deposit-noun")}),action:B.depositMultistrategy(this.vault,a.amount),pending:!1,extraInfo:{zap:!1,vaultId:e.option.vaultId}}}async fetchWithdrawOption(){const e=[this.depositToken],t=S(this.vault.chainId,e);return{id:x("vault-standard",this.vault.id,t),vaultId:this.vault.id,chainId:this.vault.chainId,selectionId:t,selectionOrder:1,inputs:e,wantedOutputs:e,strategyId:"vault",vaultType:"standard",mode:Z.Withdraw}}async fetchWithdrawQuote(e,t){d(e,1);const a=l(e);if(a.amount.lte(y))throw new Error("Quote called with 0 input amount");if(!p(a.token,this.depositToken))throw new Error("Quote called with invalid input token");const n=this.getState(),{withdrawnAmountAfterFeeWei:s}=R(a,this.vault,n),r=[{token:a.token,amount:m(s,a.token.decimals)}],i=[];return{id:O(t.id),strategyId:t.strategyId,vaultType:t.vaultType,option:t,inputs:e,outputs:r,returned:[],allowances:i,priceImpact:0}}async fetchWithdrawStep(e,t){d(e.inputs,1);const a=l(e.inputs);return{step:"withdraw",message:t("Vault-TxnConfirm",{type:t("Withdraw-noun")}),action:B.withdrawMultistrategy(this.vault,a.amount),pending:!1,extraInfo:{zap:!1,vaultId:e.option.vaultId}}}async fetchZapWithdraw(e){d(e.inputs,1);const t=l(e.inputs);if(!p(t.token,this.depositToken))throw new Error("Input token is not the deposit token");const a=this.getState(),n=C(a,this.vault.chainId),s=await A(n),r=new _.MultiCall(s,n.multicallAddress),i=j(a),{sharesToWithdrawWei:u,withdrawnAmountAfterFeeWei:h}=await G(t,this.vault,a,i,s,r);return console.log("fetchZapWithdraw",D({input:f(t.amount,t.token.decimals),sharesToWithdrawWei:u,withdrawnAmountAfterFeeWei:h})),{inputs:[{token:this.shareToken,amount:m(u,this.shareToken.decimals),max:t.max}],outputs:[{token:this.depositToken,amount:m(h,this.depositToken.decimals)}],zap:E(this.depositToken)?this.fetchNativeZapWithdraw(this.vault.earnContractAddress,this.shareToken,u):this.fetchErc20ZapWithdraw(this.vault.earnContractAddress,this.shareToken,u)}}fetchNativeZapWithdraw(e,t,a){return{target:e,value:"0",data:k.encodeFunctionCall({constant:!1,inputs:[{internalType:"uint256",name:"_shares",type:"uint256"}],name:"withdraw",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function"},[a.toString(10)]),tokens:[{token:w(t),index:v(0)}]}}fetchErc20ZapWithdraw(e,t,a){return{target:e,value:"0",data:k.encodeFunctionCall({constant:!1,inputs:[{internalType:"uint256",name:"_shares",type:"uint256"}],name:"withdraw",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function"},[a.toString(10)]),tokens:[{token:w(t),index:v(0)}]}}}export{Y as MultistrategyVaultType};
