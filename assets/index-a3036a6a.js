var x=Object.defineProperty;var N=(f,o,n)=>o in f?x(f,o,{enumerable:!0,configurable:!0,writable:!0,value:n}):f[o]=n;var v=(f,o,n)=>(N(f,typeof o!="symbol"?o+"":o,n),n);import{gu as l,gv as $,a4 as W,bO as u,gw as B,gx as T,gs as O,gt as Q,gy as I,gz as b,Y as g,gA as A,en as h,el as m,gB as P,q as w,gC as y,gD as R,ep as M,gE as S}from"./index-e33bfe5b.js";import{s as _,a as E,Z as C}from"./amounts-328c917b.js";import{g as D}from"./zap-1e909aff.js";class F{constructor(o){v(this,"providersById",{});this.providers=o,this.providers.forEach(n=>{this.providersById[n.getId()]=n})}with(o){return new F([...this.providers,o])}allowedProviders(o){const n=(o==null?void 0:o.blockProviders)||[];return n.length===0?this.providers:this.providers.filter(e=>!n.includes(e.getId()))}allowedTokens(o,n){const e=(n==null?void 0:n.blockTokens)||[];return e.length===0?o:o.filter(t=>!e.includes(t.id))}async providerSupportedTokens(o,n,e,t,s){if(!(await o.getSupportedChains(t)).includes(e))return[];const i=await o.getSupportedTokens(n,e,t);return this.allowedTokens(i,s)}async fetchTokenSupport(o,n,e,t,s){const r=this.allowedProviders(s),i=await Promise.all(r.map(c=>this.providerSupportedTokens(c,n,e,t,s))),d=o.map(c=>this.tokensSupportingFilter(i,p=>p.some(k=>l(k,c)),t));if(d.length===1)return{tokens:d,any:d[0]};const a=this.tokensSupportingFilter(i,c=>o.some(p=>c.some(k=>l(k,p))),t);return{tokens:d,any:a}}tokensSupportingFilter(o,n,e){const t=o.filter(s=>s.length>1&&n(s));return this.mergeAndSortTokens(t,e)}mergeAndSortTokens(o,n){const e=$(...o);return W(e,[t=>u(t)?1:0,t=>B(n,t.chainId,t.id),t=>t.symbol.toLowerCase()],["desc","desc","asc"])}async canSwapBetween(o,n,e,t,s,r){if(o.getId()!=="wnative"&&(u(e)||u(t))){const d=T(s,e.chainId);if(l(e,d)||l(t,d))return!1}const i=await this.providerSupportedTokens(o,n,e.chainId,s,r);return i.some(d=>l(d,e))&&i.some(d=>l(d,t))}async fetchQuotes(o,n,e){const t=this.allowedProviders(e),s=await Promise.all(t.map(c=>this.canSwapBetween(c,o.vaultId,o.fromToken,o.toToken,n,e))),r=this.providers.filter((c,p)=>s[p]);if(r.length===0)throw new Error(`No swap providers available for ${o.fromToken.symbol} -> ${o.toToken.symbol}`);const i=await Promise.allSettled(r.map(c=>c.fetchQuote(o,n))),[d,a]=O.partition(i,Q);if(a.length>0&&(console.warn(`Some quotes failed for ${o.fromToken.symbol} -> ${o.toToken.symbol}`),a.forEach(c=>console.warn(c.reason))),d.length===0)throw a.length>0?a[0].reason:new Error(`No quotes available for ${o.fromToken.symbol} -> ${o.toToken.symbol}`);return _(d.map(c=>c.value))}async fetchSwap(o,n,e){const t=this.providersById[o];if(!t)throw new Error(`Provider ${o} not found`);return await t.fetchSwap(n,e)}}class V{getId(){return"one-inch"}getTokenAddress(o){return u(o)?I:o.address}getConfigForChain(o,n){return b(n,o,"one-inch")}async fetchQuote(o,n){const e=g(n,o.fromToken.chainId),t=this.getConfigForChain(e.id,n);if(!t)throw new Error(`No one-inch aggregator config found for chain ${e.id}`);const r=await(await A(e)).getQuote({src:this.getTokenAddress(o.fromToken),dst:this.getTokenAddress(o.toToken),amount:h(o.fromAmount,o.fromToken.decimals),fee:(t.fee.value*100).toString(10)});return{providerId:this.getId(),fromToken:o.fromToken,fromAmount:o.fromAmount,toToken:o.toToken,toAmount:m(r.dstAmount,o.toToken.decimals),fee:t.fee}}async fetchSwap(o,n){const{quote:e,fromAddress:t,slippage:s}=o,r=g(n,e.fromToken.chainId),i=this.getConfigForChain(r.id,n);if(!i)throw new Error(`No one-inch aggregator config found for chain ${r.id}`);const a=await(await A(r)).getSwap({from:t,src:this.getTokenAddress(e.fromToken),dst:this.getTokenAddress(e.toToken),amount:h(e.fromAmount,e.fromToken.decimals),slippage:o.slippage*100,disableEstimate:!0,fee:(i.fee.value*100).toString(10),referrer:i.fee.recipient});return{providerId:this.getId(),fromToken:e.fromToken,fromAmount:e.fromAmount,toToken:e.toToken,toAmount:m(a.dstAmount,e.toToken.decimals),toAmountMin:E(m(a.dstAmount,e.toToken.decimals),s,e.toToken.decimals),tx:{fromAddress:a.tx.from,toAddress:a.tx.to,data:a.tx.data,value:a.tx.value,inputPosition:-1},fee:i.fee}}async getSupportedTokens(o,n,e){const t=this.getConfigForChain(n,e);if(!t)return[];if(t.blockedVaults.includes(o))return[];const s=P(e,n,"one-inch");return t.blockedTokens.length?s.filter(r=>!t.blockedTokens.includes(r.id)):s}async getSupportedChains(o){return w(o).filter(n=>!!this.getConfigForChain(n,o))}}class z{getId(){return"kyber"}getTokenAddress(o){return u(o)?I:o.address}getConfigForChain(o,n){return b(n,o,"kyber")}async fetchQuote(o,n){const e=g(n,o.fromToken.chainId),t=this.getConfigForChain(e.id,n);if(!t)throw new Error(`No kyber aggregator config found for chain ${e.id}`);const s=await y(e),r={tokenIn:this.getTokenAddress(o.fromToken),tokenOut:this.getTokenAddress(o.toToken),amountIn:h(o.fromAmount,o.fromToken.decimals),gasInclude:!0,saveGas:!1};t.fee&&t.fee.value>0&&(r.feeAmount=(t.fee.value*1e4).toString(10),r.isInBps=!0,r.chargeFeeBy="currency_in",r.feeReceiver=t.fee.recipient);const i=await s.getQuote(r);return{providerId:this.getId(),fromToken:o.fromToken,fromAmount:o.fromAmount,toToken:o.toToken,toAmount:m(i.routeSummary.amountOut,o.toToken.decimals),fee:t.fee,extra:i.routeSummary}}async fetchSwap(o,n){const{quote:e,fromAddress:t,slippage:s}=o,r=g(n,e.fromToken.chainId),i=this.getConfigForChain(r.id,n);if(!i)throw new Error(`No kyber aggregator config found for chain ${r.id}`);const a=await(await y(r)).postSwap({recipient:t,sender:t,routeSummary:e.extra,slippageTolerance:s*1e4});return{providerId:this.getId(),fromToken:e.fromToken,fromAmount:e.fromAmount,toToken:e.toToken,toAmount:m(a.amountOut,e.toToken.decimals),toAmountMin:E(m(a.amountOut,e.toToken.decimals),s,e.toToken.decimals),tx:{fromAddress:t,toAddress:a.routerAddress,data:a.data,value:u(e.fromToken)?e.extra.amountIn:"0",inputPosition:-1},fee:i.fee}}async getSupportedTokens(o,n,e){const t=this.getConfigForChain(n,e);if(!t)return[];if(t.blockedVaults.includes(o))return[];const s=P(e,n,"kyber");return t.blockedTokens.length?s.filter(r=>!t.blockedTokens.includes(r.id)):s}async getSupportedChains(o){return w(o).filter(n=>!!this.getConfigForChain(n,o))}}class G{getId(){return"wnative"}async fetchQuote(o,n){return{providerId:this.getId(),fromToken:o.fromToken,fromAmount:o.fromAmount,toToken:o.toToken,toAmount:o.fromAmount,fee:C}}async fetchSwap(o,n){const{quote:e}=o,t=e.fromToken.chainId,s=T(n,t),r=u(e.fromToken),i=h(e.fromAmount,e.fromToken.decimals);return{providerId:this.getId(),fromToken:e.fromToken,fromAmount:e.fromAmount,toToken:e.toToken,toAmount:e.fromAmount,toAmountMin:e.fromAmount,tx:{fromAddress:o.fromAddress,toAddress:s.address,data:r?this.encodeWrapCall():this.encodeUnwrapCall(i),value:r?i:"0",inputPosition:r?-1:D(0)},fee:C}}async getSupportedTokens(o,n,e){if(R(n))return[];const t=M(e,n),s=T(e,n);return[t,s]}encodeWrapCall(){return S.encodeFunctionCall({type:"function",name:"deposit",constant:!1,stateMutability:"payable",payable:!0,inputs:[],outputs:[]},[])}encodeUnwrapCall(o){return S.encodeFunctionCall({type:"function",name:"withdraw",constant:!1,payable:!1,inputs:[{type:"uint256",name:"wad"}],outputs:[]},[o])}async getSupportedChains(o){return w(o)}}export{z as KyberSwapProvider,V as OneInchSwapProvider,F as SwapAggregator,G as WNativeSwapProvider};
