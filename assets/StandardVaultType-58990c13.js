var M=Object.defineProperty;var V=(u,e,t)=>e in u?M(u,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):u[e]=t;var d=(u,e,t)=>(V(u,typeof e!="symbol"?e+"":e,t),t);import{a_ as Q,P as T,bN as b,cs as _,bX as C,bD as w,hB as p,hh as h,gu as f,Y as W,c6 as x,hC as z,ha as y,hv as A,es as k,bO as F,gE as o,en as D,he as S,hf as E,cC as B,hi as Z,cT as N,hj as P,c7 as R,aT as j,hD as G}from"./index-e33bfe5b.js";import{a as r,g as v}from"./zap-1e909aff.js";class Y{constructor(e,t){d(this,"id","standard");d(this,"vault");d(this,"depositToken");d(this,"shareToken");d(this,"getState");if(!Q(e))throw new Error("Vault is not a standard vault");const a=t();this.getState=t,this.vault=e,this.depositToken=T(a,e.chainId,e.depositTokenAddress);const n=T(a,e.chainId,e.earnContractAddress);if(!b(n))throw new Error("Share token is not an ERC20 token");this.shareToken=n}async initialize(){}calculateDepositFee(e,t){const{deposit:a}=_(t,this.vault.id);return a>0?e.amount.multipliedBy(a).decimalPlaces(e.token.decimals,C.ROUND_FLOOR):w}async fetchZapDeposit(e){p(e.inputs,1);const t=h(e.inputs);if(!f(t.token,this.depositToken))throw new Error("Input token is not the deposit token");const a=this.getState(),n=W(a,this.vault.chainId),s=await x(n),i=await new s.eth.Contract(z,this.vault.earnContractAddress).methods.getPricePerFullShare().call(),c=new C(i),m=y(t.amount,t.token.decimals),O=this.calculateDepositFee(t,a),I=y(t.amount.minus(O),t.token.decimals),g=I.shiftedBy(this.shareToken.decimals).dividedToIntegerBy(c);return console.log("fetchZapDeposit",A({ppfsRaw:i,inputWei:m,inputWeiAfterFee:I,expectedShares:g})),{inputs:e.inputs,outputs:[{token:this.shareToken,amount:k(g,this.shareToken.decimals)}],zap:F(t.token)?this.fetchNativeZapDeposit(this.vault.earnContractAddress,t.token,t.amount):this.fetchErc20ZapDeposit(this.vault.earnContractAddress,t.token,t.amount,t.max)}}fetchErc20ZapDeposit(e,t,a,n){return n?{target:e,value:"0",data:o.encodeFunctionCall({constant:!1,inputs:[],name:"depositAll",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function"},[]),tokens:[{token:r(t),index:-1}]}:{target:e,value:"0",data:o.encodeFunctionCall({constant:!1,inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"deposit",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function"},[D(a,t.decimals)]),tokens:[{token:r(t),index:v(0)}]}}fetchNativeZapDeposit(e,t,a){return{target:e,value:D(a,t.decimals),data:o.encodeFunctionCall({constant:!1,inputs:[],name:"depositBNB",outputs:[],payable:!0,stateMutability:"payable",type:"function"},[]),tokens:[{token:r(t),index:-1}]}}async fetchDepositOption(){const e=[this.depositToken],t=S(this.vault.chainId,e);return{id:E("vault-standard",this.vault.id,t),vaultId:this.vault.id,chainId:this.vault.chainId,selectionId:t,selectionOrder:1,inputs:e,wantedOutputs:e,strategyId:"vault",vaultType:"standard",mode:B.Deposit}}async fetchDepositQuote(e,t){p(e,1);const a=h(e);if(a.amount.lte(w))throw new Error("Quote called with 0 input amount");if(!f(a.token,this.depositToken))throw new Error("Quote called with invalid input token");const n=this.getState(),s=this.calculateDepositFee(a,n),l={token:a.token,amount:a.amount.minus(s)},i=b(a.token)?[{token:a.token,amount:a.amount,spenderAddress:this.vault.earnContractAddress}]:[];return{id:Z(t.id),strategyId:t.strategyId,vaultType:t.vaultType,option:t,inputs:e,outputs:[l],returned:[],allowances:i,priceImpact:0}}async fetchDepositStep(e,t){p(e.inputs,1);const a=h(e.inputs);return{step:"deposit",message:t("Vault-TxnConfirm",{type:t("Deposit-noun")}),action:N.deposit(this.vault,a.amount,a.max),pending:!1,extraInfo:{zap:!1,vaultId:e.option.vaultId}}}async fetchWithdrawOption(){const e=[this.depositToken],t=S(this.vault.chainId,e);return{id:E("vault-standard",this.vault.id,t),vaultId:this.vault.id,chainId:this.vault.chainId,selectionId:t,selectionOrder:1,inputs:e,wantedOutputs:e,strategyId:"vault",vaultType:"standard",mode:B.Withdraw}}async fetchWithdrawQuote(e,t){p(e,1);const a=h(e);if(a.amount.lte(w))throw new Error("Quote called with 0 input amount");if(!f(a.token,this.depositToken))throw new Error("Quote called with invalid input token");const n=this.getState(),{withdrawnAmountAfterFeeWei:s}=P(a,this.vault,n),l=[{token:a.token,amount:k(s,a.token.decimals)}],i=[];return{id:Z(t.id),strategyId:t.strategyId,vaultType:t.vaultType,option:t,inputs:e,outputs:l,returned:[],allowances:i,priceImpact:0}}async fetchWithdrawStep(e,t){p(e.inputs,1);const a=h(e.inputs);return{step:"withdraw",message:t("Vault-TxnConfirm",{type:t("Withdraw-noun")}),action:N.withdraw(this.vault,a.amount,a.max),pending:!1,extraInfo:{zap:!1,vaultId:e.option.vaultId}}}async fetchZapWithdraw(e){p(e.inputs,1);const t=h(e.inputs);if(!f(t.token,this.depositToken))throw new Error("Input token is not the deposit token");const a=this.getState(),n=W(a,this.vault.chainId),s=await x(n),l=new R.MultiCall(s,n.multicallAddress),i=j(a),{sharesToWithdrawWei:c,withdrawnAmountAfterFeeWei:m}=await G(t,this.vault,a,i,s,l);return console.log("fetchZapWithdraw",A({input:y(t.amount,t.token.decimals),sharesToWithdrawWei:c,withdrawnAmountAfterFeeWei:m})),{inputs:[{token:this.shareToken,amount:k(c,this.shareToken.decimals),max:t.max}],outputs:[{token:this.depositToken,amount:k(m,this.depositToken.decimals)}],zap:F(this.depositToken)?this.fetchNativeZapWithdraw(this.vault.earnContractAddress,this.shareToken,c,t.max):this.fetchErc20ZapWithdraw(this.vault.earnContractAddress,this.shareToken,c,t.max)}}fetchNativeZapWithdraw(e,t,a,n){return n?{target:e,value:"0",data:o.encodeFunctionCall({constant:!1,inputs:[],name:"withdrawAllBNB",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function"},[]),tokens:[{token:r(t),index:-1}]}:{target:e,value:"0",data:o.encodeFunctionCall({constant:!1,inputs:[{internalType:"uint256",name:"_shares",type:"uint256"}],name:"withdrawBNB",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function"},[a.toString(10)]),tokens:[{token:r(t),index:v(0)}]}}fetchErc20ZapWithdraw(e,t,a,n){return n?{target:e,value:"0",data:o.encodeFunctionCall({constant:!1,inputs:[],name:"withdrawAll",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function"},[]),tokens:[{token:r(t),index:-1}]}:{target:e,value:"0",data:o.encodeFunctionCall({constant:!1,inputs:[{internalType:"uint256",name:"_shares",type:"uint256"}],name:"withdraw",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function"},[a.toString(10)]),tokens:[{token:r(t),index:v(0)}]}}}export{Y as StandardVaultType};
