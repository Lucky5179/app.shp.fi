var D=Object.defineProperty;var V=(n,t,e)=>t in n?D(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e;var u=(n,t,e)=>(V(n,typeof t!="symbol"?t+"":t,e),e);import{O as W,P as w,cs as m,bX as I,bD as r,he as f,hf as k,cC as y,hB as d,hh as l,gu as g,bN as x,hi as T,cT as h,cA as E}from"./index-e33bfe5b.js";class R{constructor(t,e){u(this,"id","gov");u(this,"vault");u(this,"depositToken");u(this,"getState");if(!W(t))throw new Error("Vault is not a gov vault");const a=e();this.getState=e,this.vault=t,this.depositToken=w(a,t.chainId,t.depositTokenAddress)}async initialize(){}calculateDepositFee(t,e){const{deposit:a}=m(e,this.vault.id);return a>0?t.amount.multipliedBy(a).decimalPlaces(t.token.decimals,I.ROUND_FLOOR):r}calculateWithdrawFee(t,e){const{withdraw:a}=m(e,this.vault.id);return a>0?t.amount.multipliedBy(a).decimalPlaces(t.token.decimals,I.ROUND_FLOOR):r}async fetchDepositOption(){const t=[this.depositToken],e=f(this.vault.chainId,t);return{id:k("vault-gov",this.vault.id,e),vaultId:this.vault.id,chainId:this.vault.chainId,selectionId:e,selectionOrder:1,inputs:t,wantedOutputs:t,strategyId:"vault",vaultType:"gov",mode:y.Deposit}}async fetchDepositQuote(t,e){d(t,1);const a=l(t);if(a.amount.lte(r))throw new Error("Quote called with 0 input amount");if(!g(a.token,this.depositToken))throw new Error("Quote called with invalid input token");const s=this.getState(),i=this.calculateDepositFee(a,s),o={token:a.token,amount:a.amount.minus(i)},c=x(a.token)?[{token:a.token,amount:a.amount,spenderAddress:this.vault.earnContractAddress}]:[];return{id:T(e.id),strategyId:e.strategyId,vaultType:e.vaultType,option:e,inputs:t,outputs:[o],returned:[],allowances:c,priceImpact:0}}async fetchDepositStep(t,e){d(t.inputs,1);const a=l(t.inputs);return{step:"deposit-gov",message:e("Vault-TxnConfirm",{type:e("Deposit-noun")}),action:h.stakeGovVault(this.vault,a.amount),pending:!1,extraInfo:{zap:!1,vaultId:t.option.vaultId}}}async fetchWithdrawOption(){const t=[this.depositToken],e=f(this.vault.chainId,t);return{id:k("vault-gov",this.vault.id,e),vaultId:this.vault.id,chainId:this.vault.chainId,selectionId:e,selectionOrder:1,inputs:t,wantedOutputs:t,strategyId:"vault",vaultType:"gov",mode:y.Withdraw}}async fetchWithdrawQuote(t,e){d(t,1);const a=l(t);if(a.amount.lte(r))throw new Error("Quote called with 0 input amount");if(!g(a.token,this.depositToken))throw new Error("Quote called with invalid input token");const s=this.getState(),i=a.max===!0,o=[],c=this.calculateWithdrawFee(a,s),O=a.amount.minus(c),p=[{token:a.token,amount:O}];if(i){const v=E(s,this.vault.id);if(v.gt(r)){const A=w(s,this.vault.chainId,this.vault.earnedTokenAddress);p.push({token:A,amount:v})}}return{id:T(e.id),strategyId:e.strategyId,vaultType:e.vaultType,option:e,inputs:t,outputs:p,returned:[],allowances:o,priceImpact:0}}async fetchWithdrawStep(t,e){d(t.inputs,1);const a=l(t.inputs),s=a.max===!0,i=t.outputs.length>1;if(s&&i){const o=t.outputs[1];return{step:"claim-withdraw",message:e("Vault-TxnConfirm",{type:e("Claim-Withdraw-noun")}),action:h.exitGovVault(this.vault),pending:!1,extraInfo:{rewards:{token:o.token,amount:o.amount},vaultId:this.vault.id}}}return{step:"withdraw",message:e("Vault-TxnConfirm",{type:e("Withdraw-noun")}),action:h.unstakeGovVault(this.vault,a.amount),pending:!1,extraInfo:{zap:!1,vaultId:t.option.vaultId}}}async fetchZapDeposit(t){throw new Error("Gov vaults do not support zap.")}async fetchZapWithdraw(t){throw new Error("Gov vaults do not support zap.")}}export{R as GovVaultType};
