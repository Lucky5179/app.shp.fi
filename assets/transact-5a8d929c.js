var D=Object.defineProperty;var F=(n,t,e)=>t in n?D(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e;var I=(n,t,e)=>(F(n,typeof t!="symbol"?t+"":t,e),e);import{df as p,p as O,go as b,gp as $,gq as g,gr as V,gs as S,gt as _,a_ as E}from"./index-e33bfe5b.js";function T(n){return n.zap!==void 0}function y(n){let t;return async(e,a)=>(t||(t=await n()),new t(e,a))}const z={single:y(async()=>(await p(()=>import("./SingleStrategy-d998ca92.js"),["assets/SingleStrategy-d998ca92.js","assets/index-e33bfe5b.js","assets/amounts-328c917b.js","assets/zap-1e909aff.js","assets/swap-53be301f.js"])).SingleStrategy),"uniswap-v2":y(async()=>(await p(()=>import("./UniswapV2Strategy-5b6f52c3.js"),["assets/UniswapV2Strategy-5b6f52c3.js","assets/UniswapLikeStrategy-d26502c7.js","assets/index-e33bfe5b.js","assets/amounts-328c917b.js","assets/zap-1e909aff.js","assets/swap-53be301f.js","assets/Balances-1942d032.js"])).UniswapV2Strategy),solidly:y(async()=>(await p(()=>import("./SolidlyStrategy-d7569b6d.js"),["assets/SolidlyStrategy-d7569b6d.js","assets/UniswapLikeStrategy-d26502c7.js","assets/index-e33bfe5b.js","assets/amounts-328c917b.js","assets/zap-1e909aff.js","assets/swap-53be301f.js","assets/Balances-1942d032.js"])).SolidlyStrategy),curve:y(async()=>(await p(()=>import("./CurveStrategy-4f048950.js"),["assets/CurveStrategy-4f048950.js","assets/index-e33bfe5b.js","assets/amounts-328c917b.js","assets/swap-53be301f.js","assets/zap-1e909aff.js","assets/Balances-1942d032.js"])).CurveStrategy)};function m(n){let t;return async(e,a)=>{t||(t=await n());const r=new t(e,a);return await r.initialize(),r}}const Q={gov:m(async()=>(await p(()=>import("./GovVaultType-bed130f4.js"),["assets/GovVaultType-bed130f4.js","assets/index-e33bfe5b.js"])).GovVaultType),standard:m(async()=>(await p(()=>import("./StandardVaultType-58990c13.js"),["assets/StandardVaultType-58990c13.js","assets/index-e33bfe5b.js","assets/zap-1e909aff.js"])).StandardVaultType),multistrategy:m(async()=>(await p(()=>import("./MultistrategyVaultType-98b812d5.js"),["assets/MultistrategyVaultType-98b812d5.js","assets/index-e33bfe5b.js","assets/zap-1e909aff.js"])).MultistrategyVaultType)};class P{constructor(t){I(this,"id","vault");this.vaultType=t}async initialize(){}async fetchDepositOptions(){return[await this.vaultType.fetchDepositOption()]}async fetchDepositQuote(t,e){return this.vaultType.fetchDepositQuote(t,e)}async fetchDepositStep(t,e){return this.vaultType.fetchDepositStep(t,e)}async fetchWithdrawOptions(){return[await this.vaultType.fetchWithdrawOption()]}async fetchWithdrawQuote(t,e){return this.vaultType.fetchWithdrawQuote(t,e)}async fetchWithdrawStep(t,e){return this.vaultType.fetchWithdrawStep(t,e)}}class L{async getHelpersForVault(t,e){const a=e(),r=O(a,t),i=await this.getVaultTypeFor(r,e),o=b(a,r.chainId);return{vault:r,vaultType:i,zap:o,swapAggregator:await $(),getState:e}}async fetchDepositOptionsFor(t,e){const a=await this.getHelpersForVault(t,e),{vaultType:r}=a,i=[];i.push(await r.fetchDepositOption());const o=await this.getZapStrategiesForVault(a);if(o.length){const c=await g(o.map(u=>u.fetchDepositOptions()));i.push(...c.flat())}return i}async fetchDepositQuotesFor(t,e,a){const r=t[0].vaultId,i=await this.getHelpersForVault(r,a),o=V(t.map(s=>s.strategyId)),c=await Promise.all(o.map(s=>this.getStrategyById(s,i))),u=Object.fromEntries(c.map((s,h)=>[o[h],s]));await Promise.allSettled(c.map(async s=>{s.beforeQuote&&await s.beforeQuote()}));const w=await Promise.allSettled(t.map(async s=>{const v=await u[s.strategyId].fetchDepositQuote(e,s);if(!v)throw new Error(`Strategy ${s.strategyId} failed to return quote`);return v})),[f,l]=S.partition(w,_),d=f.map(s=>s.value).filter(s=>!!s).flat();if(l.length>0&&console.warn("fetchDepositQuotesFor had some rejections",l),d.length>0)return d;throw l.length>0?l[0].reason:new Error("No quotes succeeded")}async fetchDepositStep(t,e,a){const r=await this.getHelpersForVault(t.option.vaultId,e),i=await this.getStrategyById(t.option.strategyId,r);return i.beforeStep&&await i.beforeStep(),await i.fetchDepositStep(t,a)}async fetchWithdrawOptionsFor(t,e){const a=await this.getHelpersForVault(t,e),{vaultType:r}=a,i=[];i.push(await r.fetchWithdrawOption());const o=await this.getZapStrategiesForVault(a);if(o.length){const c=await g(o.map(u=>u.fetchWithdrawOptions()));i.push(...c.flat())}else console.debug("no zap strategies for",t);return i}async fetchWithdrawQuotesFor(t,e,a){const r=t[0].vaultId,i=await this.getHelpersForVault(r,a),o=V(t.map(s=>s.strategyId)),c=await Promise.all(o.map(s=>this.getStrategyById(s,i))),u=Object.fromEntries(c.map((s,h)=>[o[h],s]));await Promise.allSettled(c.map(async s=>{s.beforeQuote&&await s.beforeQuote()}));const w=await Promise.allSettled(t.map(s=>u[s.strategyId].fetchWithdrawQuote(e,s))),[f,l]=S.partition(w,_),d=f.map(s=>s.value).filter(s=>!!s).flat();if(l.length>0&&console.warn("fetchWithdrawQuotesFor had some rejections",l),d.length>0)return d;throw l.length>0?l[0].reason:new Error("No quotes succeeded")}async getVaultTypeFor(t,e){const a=Q[t.type];if(!a)throw new Error(`Vault ${t.id} has type "${t.type}", but there is no vault type builder`);const r=await a(t,e);if(!r)throw new Error(`Vault ${t.id} has type "${t.type}", but builder failed`);return r}async fetchWithdrawStep(t,e,a){const r=await this.getHelpersForVault(t.option.vaultId,e),i=await this.getStrategyById(t.option.strategyId,r);return i.beforeStep&&await i.beforeStep(),await i.fetchWithdrawStep(t,a)}async fetchVaultHasZap(t,e){const a=await this.getHelpersForVault(t,e),r=await this.getZapStrategiesForVault(a);return r.length?(await g(r.map(o=>o.fetchDepositOptions()))).flat().length>0:!1}async getZapStrategiesForVault(t){const{vault:e}=t;return E(e)?!e.zaps||e.zaps.length===0?[]:T(t)?(await Promise.all(e.zaps.map(async r=>{if(!r.strategyId){console.warn(`Vault ${e.id} has a zap config but no strategyId specified`);return}const i=z[r.strategyId];if(!i){console.warn(`Vault ${e.id} has a zap config with an unknown strategy "${r.strategyId}"`);return}try{return await i(r,t)}catch(o){console.error(`Vault ${e.id} failed to build strategy "${r.strategyId}"`,o);return}}))).filter(r=>!!r):(console.warn(`Vault ${e.id} has zaps defined but ${e.chainId} has no zap config`),[]):[]}async getStrategyById(t,e){const{vault:a,vaultType:r}=e;if(t==="vault")return new P(r);if(!T(e))throw new Error(`Strategy "${t}" requires zap contract`);if(!E(a))throw new Error(`Vault ${a.id} is not a standard vault and does not support zaps`);if(!a.zaps)throw new Error(`Vault ${a.id} has no zaps`);const i=a.zaps.find(c=>c.strategyId===t);if(!i)throw new Error(`Vault ${a.id} has no zap with strategy "${t}"`);const o=z[i.strategyId];if(!o)throw new Error(`Vault ${a.id} has a zap config with an unknown strategy "${i.strategyId}"`);return await o(i,e)}}export{L as TransactApi};
